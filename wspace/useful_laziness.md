# Useful lazy patterns in Whitespace

The mixed lazy and strict semantics of the reference interpreter are difficult
to reason with, but sometimes have useful applications.

## Exceptions as values

Since exceptions are lazily evaluated, this enables dataflow-dependent
exceptions, through error-carrying numbers.

We can have a very basic algebra for combining errors: A guard is a tag, that
produces an exception when it is evaluated, effectively
`enum Guard { Success, Fail }`. `Guard::Success` is constructed with `push 0`
(SSSL) and `Guard::Fail` is constructed with `push <empty>` (SSL).
`Guard::and` is simply `add`, which lazily combines two guards. `Guard::unwrap`
is `retrieve drop`, to force evaluation of the guard, which is at the top of the
stack, and produce an exception if it has `Guard::Fail`.

I don't think there is a way to inspect values, to see if an error is contained,
so `Guard::or` would not be possible without using a boolean flag, in which
case, there is no use for the guard, as it can be trivially derived from the
flag with a branch.

A higher-level data-carrying `Result` would be a simple wrapper over a guard,
generated by a compiler.
