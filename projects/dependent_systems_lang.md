# Designing a dependently typed systems programming language

A hybrid of Rust and Coq.

## Syntax

```bnf
 struct ::= "struct" IDENT params

   func ::= "func" IDENT params ":" type block

 params ::= "[" param0 "]"           # Implicit params
            "(" param0 ")"           # Explicit params
 param0 ::= (param ",")* param?
  param ::= IDENT ":" type           # Explicit type
          | IDENT ":" type "=" expr  # Explicit type and default value
          | IDENT "=" expr           # Type inferred from default value
          | IDENT                    # Type inferred from use in other params

  block ::= "{" (stmt ";")* expr? "}"
   stmt ::= …

   expr ::= …
          | expr ":" type            # Type ascription
          | IDENT
   type ::= expr
```

Note: There is no distinction between expressions and types in the grammar.

### Structs

This unifies Rust named and tuple structs.

### Implicit parameters

This unifies Rust type parameters (`<T>`) and Coq implicit arguments (`{T}` and
`[T]`).

Rust type parameter lists may contain lifetimes, types, and constants. With
dependent types, types and values (including constants) are unified, so it then
becomes only syntax sugar. How then would Rust's distinction between
monomorphization and dynamic dispatch be expressed?—by a compiler optimization?
What about lifetimes?

In Coq, when a function is partially applied, the application will infer and
insert implicit arguments which are defined in `{ }`, whereas implicit arguments
which are defined in `[ ]` are not inserted[^coq-implicit]. Without partial
application, this distinction disappears, as either all arguments—implicit and
explicit—are applied at once or none are.

Type parameters have the type `Type`, as in Coq `{T : Type}`, but since they are
usually used by other parameters, the compiler can usually infer that and they
can be written as `[T]`, as brief as Rust `<T>` or Coq `{T}`.

[^coq-implicit]: Coq documentation: [“Maximal and non-maximal insertion of
  implicit arguments”](https://coq.inria.fr/doc/V8.19.2/refman/language/extensions/implicit-arguments.html#maximal-and-non-maximal-insertion-of-implicit-arguments)

### Lifetimes

Likely place-oriented lifetimes, perhaps with influence from jq paths.
Alternatively, use reference counting and eliminate most cases with compiler
optimizations. What about self-referential types?

### Compile-time evaluation

- Modules as values: Can return generated modules from functions and `use` the
  types in them, so that multiple types can be generated by one function.
- Subsume `comptime`
  - Filesystem effects are modeled with incremental computation.

## Inspiration

- [“Almost Rules”](https://matklad.github.io/2022/07/10/almost-rules.html)
  by Alex Kladov (2022)
- [“Language Design: Rust’s Almost-Rules”](https://soc.me/languages/rust-almost-rules)
  by Simon Ochsenreither (2024)
